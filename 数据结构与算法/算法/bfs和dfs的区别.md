##二维数组的题目，N小于20的，适用DFS。而一般 N<= 200，N<=1000这种，一定不可能用DFS去做。而且并不只是整个题目不能用DFS，其中的每一步也不能使用DFS。##

#BFS的基本步骤#

  

*1.将初始点（一个或多个）加入一个集合尾
*2.从集合头取出点，判断初始点的周边点，将符合条件的点加入队列
*3.重复2操作，直至集合为空。(一般每个点只加入队列一次)

 
一般来说用DFS解决的问题都可以用BFS来解决。
DFS(深搜的同时考虑回溯）  
bfs＝队列，入队列，出队列；dfs=栈，压栈，出栈
bfs是按一层一层来访问的，所以适合有目标求最短路的步数，你想想层层搜索每次层就代表了一步。bfs优先访问的是兄弟节点，只有这一层全部访问完才能访问下一层，也就是说bfs第几层就代表当前可以走到的位置(结点).而dfs是按递归来实现的，它优先搜索深度，再回溯，优先访问的是没有访问过的子节点  
DFS多用于连通性问题因为其运行思想与人脑的思维很相似，故解决连通性问题更自然。BFS多用于解决最短路问题，其运行过程中需要储存每一层的信息，所以其运行时需要储存的信息量较大，如果人脑也可储存大量信息的话，理论上人脑也可运行BFS。  
总的来说多数情况下运行BFS所需的内存会大于DFS需要的内存(DFS一次访问一条路，BFS一次访问多条路)，DFS容易爆栈(栈不易"控制")，BFS通过控制队列可以很好解决"爆队列"风险。  
它们两者间各自的优势需要通过实际的问题来具体分析，根据它们各自的特点来应用于不同的问题中才能获得最优的性能。


<table ><tbody><tr><td> </td>
			<td >实现方法</td>
			<td >基本思想</td>
			<td >解决问题</td>
			<td >N规模</td>
		</tr><tr><td>DFS</td>
			<td >栈/递归</td>
			<td >回溯法，一次访问一条路，更接近人的思维方式,</td>
			<td >所有解问题，或连通性问题</td>
			<td >不能太大,&lt;=200</td>
		</tr><tr><td>BFS</td>
			<td >队列</td>
			<td >分治限界法，一次访问多条路，每一层需要存储大量信息</td>
			<td >最优解问题，如最短路径</td>
			<td >可以比较大，因为可以用队列解决,&lt;=1000</td>
		</tr></tbody></table>		
		